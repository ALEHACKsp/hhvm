diff --git a/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.cpp b/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.cpp
index 00a6d8a7..56c60844 100644
--- a/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.cpp
+++ b/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.cpp
@@ -175,6 +175,8 @@ HTTPSession::HTTPSession(
   if (!sock_->isReplaySafe()) {
     sock_->setReplaySafetyCallback(this);
   }
+
+  rateLimitingCounters_ = std::make_shared<RateLimitingCounters>();
 }
 
 uint32_t HTTPSession::getCertAuthSettingVal() {
@@ -1108,7 +1110,12 @@ void HTTPSession::onError(HTTPCodec::StreamID streamID,
         infoCallback_->onRequestBegin(*this);
       }
       if (txn) {
-        handleErrorDirectly(txn, error);
+        if (incrementDirectErrorHandlingInCurInterval()) {
+          // The rate limit has been exceeded
+          return;
+        } else {
+          handleErrorDirectly(txn, error);
+        }
       }
     } else if (newTxn) {
       onNewTransactionParseError(streamID, error);
@@ -1121,7 +1128,12 @@ void HTTPSession::onError(HTTPCodec::StreamID streamID,
 
   if (!txn->getHandler() &&
       txn->getEgressState() == HTTPTransactionEgressSM::State::Start) {
-    handleErrorDirectly(txn, error);
+    if (incrementDirectErrorHandlingInCurInterval()) {
+      // The rate limit has been exceeded
+      return;
+    } else {
+      handleErrorDirectly(txn, error);
+    }
     return;
   }
 
@@ -1137,6 +1149,11 @@ void HTTPSession::onAbort(HTTPCodec::StreamID streamID,
                           ErrorCode code) {
   VLOG(4) << "stream abort on " << *this << ", streamID=" << streamID
           << ", code=" << getErrorCodeString(code);
+
+  if (incrementNumControlMsgsInCurInterval(http2::FrameType::RST_STREAM)) {
+    return;
+  }
+
   HTTPTransaction* txn = findTransaction(streamID);
   if (!txn) {
     VLOG(4) << *this << " abort for unrecognized transaction, streamID= "
@@ -1232,6 +1249,10 @@ void HTTPSession::onGoaway(uint64_t lastGoodStreamID,
 void HTTPSession::onPingRequest(uint64_t uniqueID) {
   VLOG(4) << *this << " got ping request with id=" << uniqueID;
 
+  if (incrementNumControlMsgsInCurInterval(http2::FrameType::PING)) {
+    return;
+  }
+
   TimePoint timestamp = getCurrentTime();
 
   // Insert the ping reply to the head of writeBuf_
@@ -1274,6 +1295,9 @@ void HTTPSession::onWindowUpdate(HTTPCodec::StreamID streamID,
 
 void HTTPSession::onSettings(const SettingsList& settings) {
   DestructorGuard g(this);
+  if (incrementNumControlMsgsInCurInterval(http2::FrameType::SETTINGS)) {
+    return;
+  }
   for (auto& setting : settings) {
     if (setting.id == SettingsId::INITIAL_WINDOW_SIZE) {
       onSetSendWindow(setting.value);
@@ -1302,7 +1326,8 @@ void HTTPSession::onSettingsAck() {
 
 void HTTPSession::onPriority(HTTPCodec::StreamID streamID,
                              const HTTPMessage::HTTPPriority& pri) {
-  if (!getHTTP2PrioritiesEnabled()) {
+  if (!getHTTP2PrioritiesEnabled() ||
+      incrementNumControlMsgsInCurInterval(http2::FrameType::PRIORITY)) {
     return;
   }
   http2::PriorityUpdate h2Pri{std::get<0>(pri), std::get<1>(pri),
@@ -2589,6 +2614,73 @@ HTTPSession::incrementOutgoingStreams() {
   HTTPSessionBase::onNewOutgoingStream(outgoingStreams_);
 }
 
+bool HTTPSession::incrementNumControlMsgsInCurInterval(
+    http2::FrameType frameType) {
+  if (rateLimitingCounters_->numControlMsgsInCurrentInterval == 0) {
+    // The first time we get a "control message", we schedule a
+    // function on the event base that clears out the value of
+    // numControlMsgsInCurrentInterval. Once it is cleared, the next
+    // such event that fires causes the function to be scheduled, and the
+    // cycle repeats.
+    scheduleResetNumControlMsgs();
+  }
+
+  (rateLimitingCounters_->numControlMsgsInCurrentInterval)++;
+  if (rateLimitingCounters_->numControlMsgsInCurrentInterval >
+      maxControlMsgsPerInterval_) {
+    LOG(ERROR) << " dropping connection due to too many control messages, "
+               << "num control messages = "
+               << rateLimitingCounters_->numControlMsgsInCurrentInterval
+               << ", most recent frame type = "
+               << getFrameTypeString(frameType) << " "
+               << *this;
+    dropConnection();
+    return true;
+  }
+
+  return false;
+}
+
+bool HTTPSession::incrementDirectErrorHandlingInCurInterval() {
+  if (rateLimitingCounters_->numDirectErrorHandlingInCurrentInterval == 0) {
+    // The first time a direct error handling event fires, we schedule a
+    // function on the event base that clears out the value of
+    // numDirectErrorHandlingInCurrentInterval. Once it is cleared, the next
+    // such event that fires causes the function to be scheduled, and the
+    // cycle repeats.
+    scheduleResetDirectErrorHandling();
+  }
+
+  (rateLimitingCounters_->numDirectErrorHandlingInCurrentInterval)++;
+  if (rateLimitingCounters_->numDirectErrorHandlingInCurrentInterval >
+      maxDirectErrorHandlingPerInterval_) {
+    LOG(ERROR) << " dropping connection due to too many newly created txns "
+               << " when directly handling errors,"
+               << "num direct error handling cases = "
+               << rateLimitingCounters_->numDirectErrorHandlingInCurrentInterval
+               << " "
+               << *this;
+    dropConnection();
+    return true;
+  }
+
+  return false;
+}
+
+void HTTPSession::scheduleResetNumControlMsgs() {
+  auto ptr = rateLimitingCounters_;
+  sock_->getEventBase()->runAfterDelay([ptr]() {
+     ptr->numControlMsgsInCurrentInterval = 0;
+  }, controlMsgIntervalDuration_);
+}
+
+void HTTPSession::scheduleResetDirectErrorHandling() {
+  auto ptr = rateLimitingCounters_;
+  sock_->getEventBase()->runAfterDelay([ptr]() {
+     ptr->numDirectErrorHandlingInCurrentInterval = 0;
+  }, directErrorHandlingIntervalDuration_);
+}
+
 void
 HTTPSession::onWriteSuccess(uint64_t bytesWritten) {
   DestructorGuard dg(this);
diff --git a/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.h b/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.h
index e5668ae8..7ae28ca1 100644
--- a/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.h
+++ b/third-party/proxygen/src/proxygen/lib/http/session/HTTPSession.h
@@ -42,6 +42,13 @@ class HTTPSessionStats;
 constexpr uint32_t kDefaultMaxConcurrentOutgoingStreamsRemote = 100000;
 constexpr uint32_t kDefaultMaxConcurrentIncomingStreams = 100;
 
+// These constants define the rate at which we limit certain events.
+constexpr uint32_t kDefaultMaxControlMsgsPerInterval = 50000;
+constexpr uint32_t kDefaultControlMsgDuration = 100; // milliseconds
+
+constexpr uint32_t kDefaultMaxDirectErrorHandlingPerInterval = 100;
+constexpr uint32_t kDefaultDirectErrorHandlingDuration = 100; // milliseconds
+
 class HTTPSession:
   public HTTPSessionBase,
   public HTTPTransaction::Transport,
@@ -290,6 +297,23 @@ class HTTPSession:
 
   ~HTTPSession() override;
 
+  void setMaxControlMsgsPerInterval(uint32_t val) {
+      maxControlMsgsPerInterval_ = val;
+  }
+
+  void setControlMsgIntervalDuration(uint32_t val) {
+      controlMsgIntervalDuration_ = val;
+  }
+
+  void setMaxDirectErrorHandlingPerInterval(uint32_t val) {
+      maxDirectErrorHandlingPerInterval_ = val;
+  }
+
+  void setDirectErrorHandlingIntervalDuration(uint32_t val) {
+      directErrorHandlingIntervalDuration_ = val;
+  }
+
+
   /**
    * Called by onHeadersComplete(). This function allows downstream and
    * upstream to do any setup (like preparing a handler) when headers are
@@ -855,6 +879,16 @@ class HTTPSession:
 
   void incrementOutgoingStreams();
 
+  // returns true if the threshold has been exceeded
+  bool incrementNumControlMsgsInCurInterval(http2::FrameType frameType);
+
+  // returns true if the rate limiting threshold has been exceeded
+  bool incrementDirectErrorHandlingInCurInterval();
+
+  void scheduleResetNumControlMsgs();
+
+  void scheduleResetDirectErrorHandling();
+
   // private members
 
   std::list<ReplaySafetyCallback*> waitingForReplaySafety_;
@@ -975,6 +1009,32 @@ class HTTPSession:
    */
   uint64_t bodyBytesPerWriteBuf_{0};
 
+  struct RateLimitingCounters {
+    /**
+     * The two variables below keep track of the number of Control messages,
+     * and the number of error handling events that are handled by a newly created
+     * transaction handler seen in the current interval, respectively. These are
+     * shared_ptrs, as opposed to uint64_ts because we don't want to run into
+     * lifetime issues where the HTTPSession is destructed, and the rate
+     * limiting function is still scheduled to run on the event base.
+     */
+    uint64_t numControlMsgsInCurrentInterval{0};
+    uint64_t numDirectErrorHandlingInCurrentInterval{0};
+  };
+
+  std::shared_ptr<RateLimitingCounters> rateLimitingCounters_;
+
+  /*
+   * If the number of control messages in a controlMsgIntervalDuration_
+   * millisecond interval exceeds maxControlMsgsPerInterval_, we drop the
+   * connection
+   */
+  uint32_t maxControlMsgsPerInterval_{kDefaultMaxControlMsgsPerInterval};
+  uint32_t controlMsgIntervalDuration_{kDefaultControlMsgDuration};
+
+  uint32_t maxDirectErrorHandlingPerInterval_{kDefaultMaxDirectErrorHandlingPerInterval};
+  uint32_t directErrorHandlingIntervalDuration_{kDefaultDirectErrorHandlingDuration};
+
   /**
    * Container to hold the results of HTTP2PriorityQueue::nextEgress
    */
diff --git a/third-party/proxygen/src/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp b/third-party/proxygen/src/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp
index 501fc54b..0ef76e0d 100644
--- a/third-party/proxygen/src/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp
+++ b/third-party/proxygen/src/proxygen/lib/http/session/test/HTTPDownstreamSessionTest.cpp
@@ -3726,3 +3726,122 @@ TEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {
   flushRequestsAndLoop();
   gracefulShutdown();
 }
+
+TEST_F(HTTP2DownstreamSessionTest, TestControlMsgRateLimitExceeded) {
+  auto streamid = clientCodec_->createStream();
+
+  httpSession_->setMaxControlMsgsPerInterval(10);
+
+  // Send 7 PRIORITY, 1 SETTINGS, and 3 PING frames. This should exceed the
+  // limit of 10, causing us to drop the connection.
+  for (int i = 0; i < 7; i++) {
+    clientCodec_->generatePriority(
+      requests_, streamid, HTTPMessage::HTTPPriority(0, false, 3));
+  }
+
+  clientCodec_->generateSettings(requests_);
+
+  for (int i = 0; i < 3; i++) {
+    clientCodec_->generatePingRequest(requests_);
+  }
+
+  expectDetachSession();
+
+  flushRequestsAndLoopN(1);
+}
+
+TEST_F(HTTP2DownstreamSessionTest, TestControlMsgResetRateLimitTouched) {
+  auto streamid = clientCodec_->createStream();
+
+  httpSession_->setMaxControlMsgsPerInterval(10);
+  httpSession_->setControlMsgIntervalDuration(0);
+
+  // Send 7 PRIORITY, 1 SETTINGS, and 2 PING frames. This doesn't exceed the
+  // limit of 10.
+  for (int i = 0; i < 7; i++) {
+    clientCodec_->generatePriority(
+      requests_, streamid, HTTPMessage::HTTPPriority(0, false, 3));
+  }
+
+  clientCodec_->generateSettings(requests_);
+
+  for (int i = 0; i < 2; i++) {
+    clientCodec_->generatePingRequest(requests_);
+  }
+
+  // We should reset the number of control frames seen, enabling us to send
+  // more without hitting the rate limit
+  flushRequestsAndLoopN(2);
+
+  // Send 10 control frames. This is just within the rate limits that we have
+  // set.
+  for (int i = 0; i < 5; i++) {
+    clientCodec_->generatePriority(
+      requests_, streamid, HTTPMessage::HTTPPriority(0, false, 3));
+  }
+
+  clientCodec_->generateSettings(requests_);
+
+  for (int i = 0; i < 4; i++) {
+    clientCodec_->generatePingRequest(requests_);
+  }
+
+  flushRequestsAndLoopN(2);
+
+  httpSession_->closeWhenIdle();
+  expectDetachSession();
+  this->eventBase_.loop();
+}
+
+TEST_F(HTTP2DownstreamSessionTest, DirectErrorHandlingLimitTouched) {
+  httpSession_->setMaxDirectErrorHandlingPerInterval(10);
+  httpSession_->setDirectErrorHandlingIntervalDuration(0);
+
+  // Send ten messages, each of which cause direct error handling. Since
+  // this doesn't exceed the limit, this should not cause the connection
+  // to be dropped.
+  for (int i = 0; i < 10; i++) {
+    auto req = getGetRequest();
+    // Invalid method, causes the error to be handled directly
+    req.setMethod("11111111");
+    sendRequest(req, false);
+  }
+
+  EXPECT_CALL(mockController_, getParseErrorHandler(_, _, _)).
+               WillRepeatedly(Return(nullptr));
+
+  flushRequestsAndLoop();
+
+  for (int i = 0; i < 10; i++) {
+    auto req = getGetRequest();
+    // Invalid method, causes the error to be handled directly
+    req.setMethod("11111111");
+    sendRequest(req, false);
+  }
+
+  EXPECT_CALL(mockController_, getParseErrorHandler(_, _, _)).
+               WillRepeatedly(Return(nullptr));
+
+  flushRequestsAndLoop();
+  gracefulShutdown();
+}
+
+TEST_F(HTTP2DownstreamSessionTest, DirectErrorHandlingLimitExceeded) {
+  httpSession_->setMaxDirectErrorHandlingPerInterval(10);
+  httpSession_->setDirectErrorHandlingIntervalDuration(0);
+
+  // Send eleven messages, each of which causes direct error handling. Since
+  // this exceeds the limit, the connection should be dropped.
+  for (int i = 0; i < 11; i++) {
+    auto req = getGetRequest();
+    // Invalid method, causes the error to be handled directly
+    req.setMethod("11111111");
+    sendRequest(req, false);
+  }
+
+  EXPECT_CALL(mockController_, getParseErrorHandler(_, _, _)).
+               WillRepeatedly(Return(nullptr));
+
+  expectDetachSession();
+  flushRequestsAndLoopN(2);
+}
