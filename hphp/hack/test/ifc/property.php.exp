Policy signature for \My:
* Policied properties: mInt, other
* Unpolicied properties: mBool

Policy signature for \Other:
* Policied properties: oBool
* Unpolicied properties: oString

Analyzing __construct:
* pc: pc
* This:
    \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
    oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>>
* Return: <ret>
* Params:
    { $o -> \Other<\Other'1, lump'2, oString -> <lump'2>,
      oBool -> <.oBool'1>> }
* Final environment:
  Locals:
    { $o -> \Other<\Other'1, lump'2, oString -> <lump'2>,
      oBool -> <.oBool'1>> }
  Constraints:
    [\My < \Other, lump < lump'2, lump'2 < lump, .oBool < .oBool'1,
     .oBool'1 < .oBool, lump'2 = lump, \Other'1 < \Other, pc < \Other]

Analyzing getMInt:
* pc: pc
* This:
    \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
    oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>>
* Return: <ret>
* Params: {}
* Final environment:
  Locals: {}
  Constraints:
    [.mInt < .mInt'1, \My < .mInt'1, .mInt'1 < ret]

Analyzing setMInt:
* pc: pc
* This:
    \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
    oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>>
* Return: <ret>
* Params: { $candidate -> <$candidate> }
* Final environment:
  Locals: { $candidate -> <$candidate> }
  Constraints:
    [\My < .mInt, $candidate < .mInt, pc < .mInt]

Analyzing \tlGetMyInt:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>> }
* Final environment:
  Locals:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>> }
  Constraints:
    [.mInt < .mInt'1, \My < .mInt'1, .mInt'1 < ret]

Analyzing \tlSetMyInt:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>>;
      $val -> <$val> }
* Final environment:
  Locals:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>>;
      $val -> <$val> }
  Constraints:
    [\My < .mInt, $val < .mInt, pc < .mInt]

Analyzing \tlGetOther:
* pc: pc
* This: None
* Return: \Other<\Other, lump, oString -> <lump>, oBool -> <.oBool>>
* Params:
    { $obj ->
      \My<\My, lump'2, other -> \Other<\Other'1, lump'1, oString -> <lump'1>,
      oBool -> <.oBool'1>>, mInt -> <.mInt>, mBool -> <lump'2>> }
* Final environment:
  Locals:
    { $obj ->
      \My<\My, lump'2, other -> \Other<\Other'1, lump'1, oString -> <lump'1>,
      oBool -> <.oBool'1>>, mInt -> <.mInt>, mBool -> <lump'2>> }
  Constraints:
    [\Other'1 < .other, \My < .other, lump < lump'1, lump'1 < lump,
     .oBool < .oBool'1, .oBool'1 < .oBool, lump'1 = lump, .other < \Other]

Analyzing \tlGetOtherBool:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>> }
* Final environment:
  Locals:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>> }
  Constraints:
    [\Other < .other, \My < .other, .oBool < .oBool'1, .other < .oBool'1,
     .oBool'1 < ret]

Analyzing \tlSetOtherBool:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $bool -> <$bool>;
      $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>> }
* Final environment:
  Locals:
    { $bool -> <$bool>;
      $obj ->
      \My<\My, lump'1, other -> \Other<\Other, lump, oString -> <lump>,
      oBool -> <.oBool>>, mInt -> <.mInt>, mBool -> <lump'1>> }
  Constraints:
    [\Other < .other, \My < .other, .other < .oBool, $bool < .oBool,
     pc < .oBool]

