Policy signature for \My:
* Policied properties: mInt, other

Policy signature for \Other:
* Policied properties: oBool

Analyzing __construct:
* pc: pc
* This:
    \My<\My, lump, other -> \Other<\Other'1, lump'2, oBool -> <.oBool>>,
    mInt -> <thunk>>
* Return: <ret>
* Params: { $o -> \Other<\Other, lump'1, oBool -> <.oBool'1>> }
* Final environment:
  Locals: { $o -> \Other<\Other, lump'1, oBool -> <.oBool'1>> }
  Constraints:
    [\My < \Other'1, .oBool < .oBool'1, .oBool'1 < .oBool, lump'1 = lump'2,
     \Other < \Other'1, pc < \Other'1]

Analyzing getMInt:
* pc: pc
* This: \My<\My, lump, other -> <thunk>, mInt -> <.mInt>>
* Return: <ret>
* Params: {}
* Final environment:
  Locals: {}
  Constraints:
    [.mInt < .mInt'1, \My < .mInt'1, .mInt'1 < ret]

Analyzing setMInt:
* pc: pc
* This: \My<\My, lump, other -> <thunk>, mInt -> <.mInt>>
* Return: <ret>
* Params: { $candidate -> <$candidate> }
* Final environment:
  Locals: { $candidate -> <$candidate> }
  Constraints:
    [\My < .mInt, $candidate < .mInt, pc < .mInt]

Analyzing \tlGetMyInt:
* pc: pc
* This: None
* Return: <ret>
* Params: { $obj -> \My<\My, lump, other -> <thunk>, mInt -> <.mInt>> }
* Final environment:
  Locals: { $obj -> \My<\My, lump, other -> <thunk>, mInt -> <.mInt>> }
  Constraints:
    [.mInt < .mInt'1, \My < .mInt'1, .mInt'1 < ret]

Analyzing \tlSetMyInt:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $obj -> \My<\My, lump, other -> <thunk>, mInt -> <.mInt>>;
      $val -> <$val> }
* Final environment:
  Locals:
    { $obj -> \My<\My, lump, other -> <thunk>, mInt -> <.mInt>>;
      $val -> <$val> }
  Constraints:
    [\My < .mInt, $val < .mInt, pc < .mInt]

Analyzing \tlGetOther:
* pc: pc
* This: None
* Return: \Other<\Other, lump, oBool -> <.oBool>>
* Params:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other'1, lump'2, oBool -> <.oBool'1>>,
      mInt -> <thunk>> }
* Final environment:
  Locals:
    { $obj ->
      \My<\My, lump'1, other -> \Other<\Other'1, lump'2, oBool -> <.oBool'1>>,
      mInt -> <thunk>> }
  Constraints:
    [\Other'1 < .other, \My < .other, .oBool < .oBool'1, .oBool'1 < .oBool,
     lump'2 = lump, .other < \Other]

Analyzing \tlGetOtherBool:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $obj ->
      \My<\My, lump, other -> \Other<\Other, lump'1, oBool -> <.oBool>>,
      mInt -> <thunk>> }
* Final environment:
  Locals:
    { $obj ->
      \My<\My, lump, other -> \Other<\Other, lump'1, oBool -> <.oBool>>,
      mInt -> <thunk>> }
  Constraints:
    [\Other < .other, \My < .other, .oBool < .oBool'1, .other < .oBool'1,
     .oBool'1 < ret]

Analyzing \tlSetOtherBool:
* pc: pc
* This: None
* Return: <ret>
* Params:
    { $bool -> <$bool>;
      $obj ->
      \My<\My, lump, other -> \Other<\Other, lump'1, oBool -> <.oBool>>,
      mInt -> <thunk>> }
* Final environment:
  Locals:
    { $bool -> <$bool>;
      $obj ->
      \My<\My, lump, other -> \Other<\Other, lump'1, oBool -> <.oBool>>,
      mInt -> <thunk>> }
  Constraints:
    [\Other < .other, \My < .other, .other < .oBool, $bool < .oBool,
     pc < .oBool]

