Policy signature for \C:
* Policied properties: cx
* Unpolicied properties: cy, cd

Policy signature for \D:
* Policied properties: 
* Unpolicied properties: di

Analyzing __construct:
* pc: pc
* This:
    \C<\C, lump, cy -> <lump>, cx -> <.cx>,
    cd -> \D<lump, lump, di -> <lump>>>
* Return: <ret>
* Params: { $cd -> \D<\D, lump'1, di -> <lump'1>> }
* Final environment:
  Locals: { $cd -> \D<\D, lump'1, di -> <lump'1>> }
  Constraints:
    [\C < lump, lump < lump'1, lump'1 < lump, lump'1 = lump, \D < lump,
     pc < lump]

Analyzing testGetUnpolicied:
* pc: pc
* This:
    \C<\C, lump, cy -> <lump>, cx -> <.cx>,
    cd -> \D<lump, lump, di -> <lump>>>
* Return: \D<\D, lump'1, di -> <lump'1>>
* Params: {}
* Final environment:
  Locals: {}
  Constraints:
    [lump < .cd, \C < .cd, lump'1 < lump, lump < lump'1, lump = lump'1,
     .cd < \D]

Analyzing testSetMultipleUnpolicied:
* pc: pc
* This:
    \C<\C, lump, cy -> <lump>, cx -> <.cx>,
    cd -> \D<lump, lump, di -> <lump>>>
* Return: <ret>
* Params: { $d -> \D<\D, lump'1, di -> <lump'1>> }
* Final environment:
  Locals: { $d -> \D<\D, lump'1, di -> <lump'1>> }
  Constraints:
    [\C < lump, Bot < lump, pc < lump, \C < lump, lump < lump'1,
     lump'1 < lump, lump'1 = lump, \D < lump, pc < lump]

Analyzing testSetDeep:
* pc: pc
* This:
    \C<\C, lump, cy -> <lump>, cx -> <.cx>,
    cd -> \D<lump, lump, di -> <lump>>>
* Return: <ret>
* Params: { $i -> <$i> }
* Final environment:
  Locals: { $i -> <$i> }
  Constraints:
    [lump < .cd, \C < .cd, .cd < lump, $i < lump, pc < lump]

Analyzing __construct:
* pc: pc
* This: \D<\D, lump, di -> <lump>>
* Return: <ret>
* Params: { $di -> <$di> }
* Final environment:
  Locals: { $di -> <$di> }
  Constraints:
    [\D < lump, $di < lump, pc < lump]

