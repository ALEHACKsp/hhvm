Policy signature for \C:
* Policied properties: cx

Policy signature for \D:
* Policied properties: 

Analyzing __construct:
* pc: pc
* This: \C<\C, lump, cx -> <.cx>>
* Return: <ret>
* Params: { $cd -> \D<\D, lump'1, > }
* Final environment:
  Locals: { $cd -> \D<\D, lump'1, > }
  Constraints:
    [\C < lump, lump'1 = lump, \D < lump, pc < lump]

Analyzing testGetUnpolicied:
* pc: pc
* This: \C<\C, lump, cx -> <.cx>>
* Return: \D<\D, lump'1, >
* Params: {}
* Final environment:
  Locals: {}
  Constraints:
    [lump < .cd, \C < .cd, lump = lump'1, .cd < \D]

Analyzing testSetMultipleUnpolicied:
* pc: pc
* This: \C<\C, lump, cx -> <.cx>>
* Return: <ret>
* Params: { $d -> \D<\D, lump'1, > }
* Final environment:
  Locals: { $d -> \D<\D, lump'1, > }
  Constraints:
    [\C < lump, Bot < lump, pc < lump, \C < lump, lump'1 = lump, \D < lump,
     pc < lump]

Analyzing testSetDeep:
* pc: pc
* This: \C<\C, lump, cx -> <.cx>>
* Return: <ret>
* Params: { $i -> <$i> }
* Final environment:
  Locals: { $i -> <$i> }
  Constraints:
    [lump < .cd, \C < .cd, .cd < lump, $i < lump, pc < lump]

Analyzing __construct:
* pc: pc
* This: \D<\D, lump, >
* Return: <ret>
* Params: { $di -> <$di> }
* Final environment:
  Locals: { $di -> <$di> }
  Constraints:
    [\D < lump, $di < lump, pc < lump]

